name: Update API Status JSON

on:
  schedule:
  - cron: "4,13,22,34,41,53 * * * *"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  generate-status:
    runs-on: ubuntu-latest
    environment: mine  
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch Health and Generate status.json
        env:
          BBS_API_URL: ${{ secrets.BBS_API_URL }}
          RURUNA_API_URL: ${{ secrets.RURUNA_API_URL }}
          SUPPORT_API_URL: ${{ secrets.SUPPORT_API_URL }}
          ACCOUNTS_API_URL: ${{ secrets.ACCOUNTS_API_URL }}
        run: |
          cat << 'EOF' > generate.js
          const fs = require('fs');

          // 1. APIエンドポイント
          const apiEndpoints = [
            { id: 'bbs', name: '24.anon API', url: process.env.BBS_API_URL },
            { id: 'ruruna', name: 'Ruruna AI API', url: process.env.RURUNA_API_URL },
            { id: 'support', name: 'サポートお問い合わせ API', url: process.env.SUPPORT_API_URL },
            { id: 'accounts', name: 'Heyeteアカウント API', url: process.env.ACCOUNTS_API_URL }
          ];

          // 2. Webサーバーエンドポイント
          const webEndpoints = [
            { id: 'web-top', name: '総合トップサイト', url: 'https://www.heyete.com/test.html' },
            { id: 'web-myaccounts', name: 'アカウントダッシュボード', url: 'https://myaccount.heyete.com/test' },
            { id: 'web-accounts', name: 'Heyeteアカウントログイン等', url: 'https://accounts.heyete.com/test' },
            { id: 'web-ruruna', name: 'Ruruna AI', url: 'https://ruruna.heyete.com/test.html' },
            { id: 'web-anon', name: '24.anon', url: 'https://anon.heyete.com/test.html' },
            { id: 'web-news', name: 'Heyete News', url: 'https://news.heyete.com/test.html' },
            { id: 'web-blog', name: 'Heyete Blog', url: 'https://blog.heyete.com/test.html' },
            { id: 'web-dev', name: 'Heyete Developer', url: 'https://dev.heyete.com/test.html' },
            { id: 'web-corp', name: 'コーポレートサイト', url: 'https://corp.heyete.com/test.html' },
            { id: 'web-policies', name: '規約とポリシー', url: 'https://policies.heyete.com/test.html' },
            { id: 'web-support', name: 'サポートお問い合わせ', url: 'https://support.heyete.com/test.html' },
            { id: 'web-docs', name: '資料サイト', url: 'https://docs.heyete.net/test.html' },
            { id: 'web-anon-lite', name: '24.anon 軽量版', url: 'https://anon.heyete.net/test.html' }
          ];

          // 単一の問い合わせを行う関数
          async function singleCheck(ep, isApi) {
            const start = Date.now();
            try {
              if (!ep.url) {
                return { status: 'unknown', message: 'URL未設定', latency_ms: 0 };
              }

              // 10秒のタイムアウトを設定
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 10000);

              const options = { 
                signal: controller.signal,
                headers: {
                  "User-Agent": "HeyeteBot"
                }
              };

              if (isApi) {
                options.headers["Origin"] = "https://support.heyete.com";
              }

              const res = await fetch(ep.url, options);
              clearTimeout(timeoutId);
              
              const latency = Date.now() - start;

              if (res.ok) {
                let status = 'operational';
                let details = null;

                if (isApi) {
                  const data = await res.json().catch(() => ({}));
                  // 既存のdegraded判定ロジック
                  const hasDepError = data.dependencies && Object.values(data.dependencies).some(v => String(v).includes('failed') || String(v).includes('error'));
                  if (hasDepError) status = 'degraded';
                  details = data;
                }
                return { status, latency_ms: latency, details, code: res.status };
              } else {
                return { status: 'down', latency_ms: latency, code: res.status };
              }
            } catch (err) {
              return { status: 'down', latency_ms: Date.now() - start, error: err.message };
            }
          }

          // 3回分の結果を集計する関数
          function aggregateResults(ep, attempts) {
            let totalLatency = 0;
            let validLatencyCount = 0;
            const statusCounts = {};

            attempts.forEach(a => {
              if (typeof a.latency_ms === 'number') {
                totalLatency += a.latency_ms;
                validLatencyCount++;
              }
              statusCounts[a.status] = (statusCounts[a.status] || 0) + 1;
            });

            // 応答速度の平均化
            const avgLatency = validLatencyCount > 0 ? Math.round(totalLatency / validLatencyCount) : 0;

            // ステータスの多数決
            let majorityStatus = 'unknown';
            let maxCount = -1;
            for (const [status, count] of Object.entries(statusCounts)) {
              if (count > maxCount) {
                maxCount = count;
                majorityStatus = status;
              }
            }

            // 多数決で選ばれたステータスを持つ直近の試行を代表値としてエラー情報などを取得
            const representative = attempts.slice().reverse().find(a => a.status === majorityStatus) || attempts[attempts.length - 1];

            const result = {
              id: ep.id,
              name: ep.name,
              status: majorityStatus,
              latency_ms: avgLatency
            };

            // 既存コードに基づくエラーや詳細情報を付与
            if (representative.details) result.details = representative.details;
            if (representative.code) result.code = representative.code;
            if (representative.error) result.error = representative.error;
            if (representative.message) result.message = representative.message;

            return result;
          }

          async function check() {
            const maxPasses = 3;
            const waitMs = 20000; // 20秒待機

            // 試行ごとの結果保存用オブジェクト
            const endpointsData = {};
            apiEndpoints.forEach(ep => endpointsData[ep.id] = { ep, isApi: true, attempts: [] });
            webEndpoints.forEach(ep => endpointsData[ep.id] = { ep, isApi: false, attempts: [] });

            for (let pass = 1; pass <= maxPasses; pass++) {
              console.log(`[Pass ${pass}/${maxPasses}] チェックを開始します...`);
              
              // 全てのAPIエンドポイントに問い合わせ
              for (const ep of apiEndpoints) {
                endpointsData[ep.id].attempts.push(await singleCheck(ep, true));
              }
              // 全てのWebエンドポイントに問い合わせ
              for (const ep of webEndpoints) {
                endpointsData[ep.id].attempts.push(await singleCheck(ep, false));
              }

              // 最終パス以外は20秒待機
              if (pass < maxPasses) {
                console.log(`次のチェックまで ${waitMs / 1000} 秒待機します...`);
                await new Promise(resolve => setTimeout(resolve, waitMs));
              }
            }

            console.log(`集計処理を実行中...`);
            const apiResults = [];
            const webResults = [];

            // 全ての結果を集計
            apiEndpoints.forEach(ep => apiResults.push(aggregateResults(ep, endpointsData[ep.id].attempts)));
            webEndpoints.forEach(ep => webResults.push(aggregateResults(ep, endpointsData[ep.id].attempts)));

            const allResults = [...apiResults, ...webResults];
            const isAllOk = allResults.every(r => r.status === 'operational' || r.status === 'unknown');

            const output = {
              last_updated: new Date().toISOString(),
              system_status: isAllOk ? 'all_systems_operational' : 'partial_outage',
              api_services: apiResults,
              web_services: webResults
            };
            
            fs.writeFileSync('status.json', JSON.stringify(output, null, 2));
            console.log("status.json generated successfully.");
          }
          
          check();
          EOF
          
          node generate.js

      - name: Commit and Push changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add status.json
          
          git diff --quiet && git diff --staged --quiet || (git commit -m "Auto-update system status [skip ci]" && git push)
